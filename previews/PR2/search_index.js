var documenterSearchIndex = {"docs":
[{"location":"base/#MemViews.jl","page":"MemViews in Base","title":"MemViews.jl","text":"","category":"section"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"It is my hope that MemViews, or something like MemViews, will eventually be moved into Base Julia. This is because Base Julia, too, includes code that uses the concept of a memory-backed array. However, Base currently lacks any kind of interface and internal API to handle memory-backed objects.","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"See the related issue on JuliaLang/julia.","category":"page"},{"location":"base/#What's-wrong-with-SubArrays-of-Memory-as-memory-views?","page":"MemViews in Base","title":"What's wrong with SubArrays of Memory as memory views?","text":"","category":"section"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"SubArray is generic over too much, and is therefore too hard to reason about, and to uphold its guarantees.","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"First, it's generic over the array type, meaning it may be backed by Memory or Vector, but also UnitRange or Base.LogRange (bitstypes, so not backed by memory), BitMatrix (memory-backed, but elements are stored packed), OffsetArrays, CodeUnits (memory-backed but immutable) and many more. What can you do with the underlying array, generally speaking? Take a pointer to it? No. Assume one-based indexing? No. Assume a stride of one? No. Assume mutability? No.","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"Second, it's generic over the index type. It may be UnitRange{Int}, of course, but also Base.OneTo{UInt16}, or StepRange{BigInteger}, CartesianIndices (which it itself generic over the indexes), Colon. Can you define the subset of these types which indicate dense indices? I can't.","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"Third, it's multidimensional. It may collect to a Vector or Matrix.","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"This is not a design flaw of SubArray - it's a perfectly fine design choice, which enables SubArray to be extremely flexible and broadly useful. Unfortunately, it also makes it nearly impossible to write robust, low-level code using SubArray, because it's almost imopssible not to violate the assumptions of a subset of SubArrays many concrete types. Practically speaking, what happens is that methods taking SubArray fall back to only assuming what can be assumed about AbstractArray - which may be inefficient, and buggy (as the recurring bugs due to assumption of one-based indexing has taught us).","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"In contrast, a MemView{T} is always represented by exactly a MemoryRef{T} and an Int as length. You know exactly what you get.","category":"page"},{"location":"base/#Design-decisions","page":"MemViews in Base","title":"Design decisions","text":"","category":"section"},{"location":"base/#Mutability","page":"MemViews in Base","title":"Mutability","text":"","category":"section"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"Mutable and immutable memory views are statically distinguished, such that users can write methods that only take mutable memory views. This will statically prevent users from accidentally mutating e.g. strings.","category":"page"},{"location":"base/#MemKind","page":"MemViews in Base","title":"MemKind","text":"","category":"section"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"The MemKind trait is used because constructing a MemView only for dispatch purposes may not be able to be optimised away by the compiler for some types (currently, strings).","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"MemKind could be replaced with a function that returned nothing, or the correct MemView type directly, but it's nicer to dispatch on ::MemKind than on ::Union{Nothing, Type{<:MemView}}.","category":"page"},{"location":"base/#Limitations","page":"MemViews in Base","title":"Limitations","text":"","category":"section"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"Currently, MemView does not make use of Core.GenericMemory's additional parameters, such as atomicity or address space. This may easily be added with a GenericMemView type, similar to Memory / GenericMemory.\nI can't figure out how to support reinterpreted arrays. Any way I can think of doing so will sigificantly complicate MemView, which takes away some of the appeal of this type's simplicity. It's possible that reinterpreted arrays are so outside Julia's ordinary memory management that this simply can't be done.\nCurrently, Strings are not backed by Memory in Julia. Therefore, creating a MemView of a string requires heap-allocating a new Memory pointing to the existing memory of the string. This can be fixed if String is re-implemented to be backed by Memory, but I don't know enough details about the implementation of String to know if this is practical.","category":"page"},{"location":"base/#Alternative-proposal","page":"MemViews in Base","title":"Alternative proposal","text":"","category":"section"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"In examples/alternative.jl, there is an implementation where a MemView is just a pointer and a length. This makes it nearly identical to Random.UnsafeView, however, compared to UnsafeView, this propsal has:","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"The MemKind trait, useful to control dispatch to functions that can treat arrays as being memory\nThe distinction between mutable and immutable memory views","category":"page"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"Overall, I like the alternative proposal less. Raw pointers are bad for safety and ergonomics, and they interact less nicely with the Julia runtime. Also, the existing GenericMemoryRef is essentially perfect for this purpose.","category":"page"},{"location":"base/#Advantages","page":"MemViews in Base","title":"Advantages","text":"","category":"section"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"Pointer-based memviews are cheaper to construct, and do not allocate for strings, unlike Memory. Perhaps in the future, strings too will be backed by Memory.\nTheir interaction with the GC is simpler (as there is no interaction)","category":"page"},{"location":"base/#Disadvantages","page":"MemViews in Base","title":"Disadvantages","text":"","category":"section"},{"location":"base/","page":"MemViews in Base","title":"MemViews in Base","text":"While some low-level methods using MemView will just forward to calling external libraries where using a pointer is fine, many will be written in pure Julia. There, it's less nice to have raw pointers.\nCode using pointer-based memviews must make sure to only have the views exist inside GC.@preserve blocks, which is annoying and will almost certainly be violated accidentally somewhere\nWe can't use advantages of the existing Memory infrasrtructure, e.g. having a GenericMemRef which supports atomic memory.","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"CurrentModule = MemViews\nDocTestSetup = quote\n    using MemViews\nend","category":"page"},{"location":"interfaces/#MemViews-in-interfaces","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"","category":"section"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"The intended purpose of the MemView type is to ease manipulation of memory-backed objects through a kind of low-level abstraction. Strings, substrings, Memory, dense views of Matrix and countless other types all have the same data representation, namely as simply a chunk of memory. This means they share important properties: Searching for a one-byte Char inside a String needs to ccall the exact same memchr as searching for Int8 in a subarray of Memory. Likewise, checking that two substrings are equal can use the same implementation as code checking that two bytearrays are equal. Obviously, writing the same implementation for each of these types is wasteful.","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"Unfortunately, Julia's system of abstract types are poorly equipped to handle this. This is because abstract types represent shared behaviour, whereas in this case, what unites these many different types are the underlying representation - exactly the thing that abstract types want to paper over!","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"MemViews.jl addresses this by introducing two types: At the bottom of abstraction, the simple MemView type is most basic, unified instantiation of the underlying representation (a chunk of memory). At the top, the MemKind trait controls dispatch such that the low-level MemView implementation is called for the right types. The idea is that whenever you write a method that operates on \"just\" a chunk of memory, you implement it for MemView. Then, you write methods with MemKind to make sure all the proper function calls gets dispatched to your MemView implementation.","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"tip: Tip\nEven if you only ever intend a method to work for, say, Vector, it can still be a good idea to implement it for MemView. First, it makes it explicit that you only use Vector for its properties as a chunk of memory, and not for, say, its ability to be resized. Second, you can implement the method for ImmutableMemView, letting both caller and callee know that the argument is not being mutated. Third, after implementing your method for MemView, it may be easy to also make your method work for Memory and other memory-backed types!","category":"page"},{"location":"interfaces/#The-MemKind-trait","page":"MemViews in interfaces","title":"The MemKind trait","text":"","category":"section"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"MemKind answers the question: Can instances of a type be treated as equal to its own memory view? For a type T, MemKind(T) returns one of two types:","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"NotMemory() if Ts are not equivalent to its own memory. Examples include Int, which has no memory representation because they are not heap allocated, and String, which are backed by memory, but which are semantically different from an AbstractVector containing its bytes.\nIsMemory{M}() where M is a concrete subtype of MemView, if instances of T are equivalent to their own memory. Examples include Arrays and Codeunits{String}. For these objects, it's the case that x == MemView(x).","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"julia> MemKind(Vector{Union{Int32, UInt32}})\nIsMemory{MutableMemView{Union{Int32, UInt32}}}()\n\njulia> MemKind(Matrix{String})\nIsMemory{MutableMemView{String}}()\n\njulia> MemKind(SubString{String})\nNotMemory()","category":"page"},{"location":"interfaces/#Implementing-MemView-interfaces","page":"MemViews in interfaces","title":"Implementing MemView interfaces","text":"","category":"section"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"When implementing a method that has a fast-past for memory-like types, you typically want to","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"At the top level, dispatch on MemKind of your argument to funnel the memory-like objects into your optimised MemView function\nAt the low level, use MemView for the implementation of the optimised version","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"An example could be:","category":"page"},{"location":"interfaces/","page":"MemViews in interfaces","title":"MemViews in interfaces","text":"# Dispatch on `MemKind`\nmy_hash(x) = my_hash(MemKind(typeof(x)), x)\n\n# For objects that are bytes, call the function taking only the memory\n# representation of `x`\nmy_hash(::IsMemory{<:MemView{UInt8}}, x) = my_hash(ImmutableMemView(x))\n\n# IsMemory with eltype other than UInt8 can't use the fast low-level function\nmy_hash(T::IsMemory, x) = my_hash(NotMemory(), x)\n\nfunction my_hash(::NotMemory, x)\n    # fallback implementation\nend\n\nfunction my_hash(mem::ImmutableMemView{UInt8})\n    # some optimised low-level memory manipulation with `mem` of bytes\nend\n\n# Handle e.g. strings separately, since they are not semantically equal to\n# an array of elements in memory, but for this method in particular,\n# we want to treat strings as if they are.\nfunction my_hash(x::Union{String, SubString{String}})\n    my_hash(MemView(x))\nend","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"CurrentModule = MemViews\nDocTestSetup = quote\n    using MemViews\nend","category":"page"},{"location":"#MemViews.jl","page":"MemViews","title":"MemViews.jl","text":"","category":"section"},{"location":"","page":"MemViews","title":"MemViews","text":"This package provide the MemView type, which is a lightweight and simple view into Memory. The MemView type is a useful low-level building block for code that operates on chunks of memory.","category":"page"},{"location":"#Features:","page":"MemViews","title":"Features:","text":"","category":"section"},{"location":"","page":"MemViews","title":"MemViews","text":"Simple and easy to reason about\nLow-overhead, efficient methods\nA safer alternative to pointers","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"The MemView type has the following layout:","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"struct MemView{T, M} <: AbstractVector{T}\n    ref::MemoryRef{T},\n    len::Int\nend","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"The M parameter is a Symbol and must be :immutable or :mutable. MemViews also provide the following aliases for convenience:","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"const MutableMemView{T} = MemView{T, :mutable}\nconst ImmutableMemView{T} = MemView{T, :immutable}","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"Immutable memory views are immutable, in that they do not support setindex! or other mutating methods. The existence of an ImmutableMemView does not protect its underlying data from being mutated through another variable.","category":"page"},{"location":"#Usage","page":"MemViews","title":"Usage","text":"","category":"section"},{"location":"#Constructing-memory-views","page":"MemViews","title":"Constructing memory views","text":"","category":"section"},{"location":"","page":"MemViews","title":"MemViews","text":"Construct memory views from x with MemView(x). MemViews should be constructable from any type that is stored as an array densely in memory. It can also be conctructed from other non-array types that are represented by a chunk of memory (like a String). By default, constructors exists for the memory-backed types in Base:","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"# Vectors\n@assert MemView([\"a\", \"b\", \"c\"]) isa MemView\n\n# Strings\n@assert MemView(\"abc\") isa MemView\n\n# Even complex nested memory-backed types\n@assert MemView(view(codeunits(view(\"abcd\", Base.OneTo(2))), :)) isa MemView","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"For values x that are mutable such as Memorys and Arrays (and SubArrays of those), MemView(x) return MutableMemView:","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"@assert MemView(Int32[1,2,3]) isa MutableMemView{Int32}\n@assert MemView(Memory{String}(undef, 3)) isa MutableMemView{String}","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"For values that are immutable, MemView return ImmutableMemViews:","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"@assert MemView(\"abc\") isa ImmutableMemView{UInt8}","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"The constructor ImmutableMemView(x) will construct an immutable view no matter if the type returned by MemView(x) is mutable or not. This is because it's always possible to convert a mutable memory view to an immutable one:","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"@assert MemView(UInt[]) isa MutableMemView{UInt}\n@assert ImmutableMemView(UInt[]) isa ImmutableMemView{UInt}","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"Hence, when adding new constructors for new types, you should only add methods to MemView. This should return a mutable memview where possible.","category":"page"},{"location":"#Indexing","page":"MemViews","title":"Indexing","text":"","category":"section"},{"location":"","page":"MemViews","title":"MemViews","text":"MemView{T} is a subtype of AbstractVector{T}, and mostly behave like you would expect an abstract vector to behave w.r.t. indexing:","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"mem = MemView([1,2,3,4,5,6,7,8])\n\nprintln(mem[2])\nprintln(mem[2:4])\nprintln(mem[end])\nprintln(mem[:])\n\n# output\n2\n[2, 3, 4]\n8\n[1, 2, 3, 4, 5, 6, 7, 8]","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"One exception is slicing, which does not copy the underlying data, but simply returns a new view of the same data. To copy explicitly, use copy, which will create a new MemView that looks into a copy of the underlying data:","category":"page"},{"location":"","page":"MemViews","title":"MemViews","text":"mem1 = MemView([1,2,3])\nmem2 = mem1[1:3]\nmem3 = copy(mem1)\nmem1[1] = 3\nprintln(mem2[1])\nprintln(mem3[1])\n\n# output\n3\n1","category":"page"}]
}
