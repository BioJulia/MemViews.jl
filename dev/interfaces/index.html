<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MemViews in interfaces · MemViews.jl</title><meta name="title" content="MemViews in interfaces · MemViews.jl"/><meta property="og:title" content="MemViews in interfaces · MemViews.jl"/><meta property="twitter:title" content="MemViews in interfaces · MemViews.jl"/><meta name="description" content="Documentation for MemViews.jl."/><meta property="og:description" content="Documentation for MemViews.jl."/><meta property="twitter:description" content="Documentation for MemViews.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MemViews.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">MemViews</a></li><li class="is-active"><a class="tocitem" href>MemViews in interfaces</a><ul class="internal"><li><a class="tocitem" href="#The-MemKind-trait"><span>The <code>MemKind</code> trait</span></a></li><li><a class="tocitem" href="#Implementing-MemView-interfaces"><span>Implementing <code>MemView</code> interfaces</span></a></li></ul></li><li><a class="tocitem" href="../base/">MemViews in Base</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MemViews in interfaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MemViews in interfaces</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MemViews-in-interfaces"><a class="docs-heading-anchor" href="#MemViews-in-interfaces">MemViews in interfaces</a><a id="MemViews-in-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#MemViews-in-interfaces" title="Permalink"></a></h1><p>The intended purpose of the MemView type is to ease manipulation of memory-backed objects through a kind of low-level abstraction. Strings, substrings, <code>Memory</code>, dense views of <code>Matrix</code> and countless other types all have the same data representation, namely as simply a chunk of memory. This means they share important properties: Searching for a one-byte <code>Char</code> inside a <code>String</code> needs to ccall the exact same <code>memchr</code> as searching for <code>Int8</code> in a subarray of <code>Memory</code>. Likewise, checking that two substrings are equal can use the same implementation as code checking that two bytearrays are equal. Obviously, writing the same implementation for each of these types is wasteful.</p><p>Unfortunately, Julia&#39;s system of abstract types are poorly equipped to handle this. This is because abstract types represent shared <em>behaviour</em>, whereas in this case, what unites these many different types are the underlying <em>representation</em> - exactly the thing that abstract types want to paper over!</p><p>MemViews.jl addresses this by introducing two types: At the bottom of abstraction, the simple <code>MemView</code> type is most basic, unified instantiation of the underlying representation (a chunk of memory). At the top, the <code>MemKind</code> trait controls dispatch such that the low-level <code>MemView</code> implementation is called for the right types. The idea is that whenever you write a method that operates on &quot;just&quot; a chunk of memory, you implement it for <code>MemView</code>. Then, you write methods with <code>MemKind</code> to make sure all the proper function calls gets dispatched to your <code>MemView</code> implementation.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Even if you only ever intend a method to work for, say, <code>Vector</code>, it can still be a good idea to implement it for <code>MemView</code>. First, it makes it explicit that you only use <code>Vector</code> for its properties as a chunk of memory, and not for, say, its ability to be resized. Second, you can implement the method for <code>ImmutableMemView</code>, letting both caller and callee know that the argument is not being mutated. Third, after implementing your method for <code>MemView</code>, it may be easy to also make your method work for <code>Memory</code> and other memory-backed types!</p></div></div><h2 id="The-MemKind-trait"><a class="docs-heading-anchor" href="#The-MemKind-trait">The <code>MemKind</code> trait</a><a id="The-MemKind-trait-1"></a><a class="docs-heading-anchor-permalink" href="#The-MemKind-trait" title="Permalink"></a></h2><p><code>MemKind</code> answers the question: Can instances of a type be treated as equal to its own memory view? For a type <code>T</code>, <code>MemKind(T)</code> returns one of two types:</p><ul><li><code>NotMemory()</code> if <code>T</code>s are not equivalent to its own memory. Examples include <code>Int</code>, which has no memory representation because they are not heap allocated, and <code>String</code>, which <em>are</em> backed by memory, but which are semantically different from an <code>AbstractVector</code> containing its bytes.</li><li><code>IsMemory{M}()</code> where <code>M</code> is a concrete subtype of <code>MemView</code>, if instances of <code>T</code> <em>are</em> equivalent to their own memory. Examples include <code>Array</code>s and <code>Codeunits{String}</code>. For these objects, it&#39;s the case that <code>x == MemView(x)</code>.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; MemKind(Vector{Union{Int32, UInt32}})
IsMemory{MutableMemView{Union{Int32, UInt32}}}()

julia&gt; MemKind(Matrix{String})
IsMemory{MutableMemView{String}}()

julia&gt; MemKind(SubString{String})
NotMemory()</code></pre><h2 id="Implementing-MemView-interfaces"><a class="docs-heading-anchor" href="#Implementing-MemView-interfaces">Implementing <code>MemView</code> interfaces</a><a id="Implementing-MemView-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-MemView-interfaces" title="Permalink"></a></h2><p>When implementing a method that has a fast-past for memory-like types, you typically want to</p><ul><li>At the top level, dispatch on <code>MemKind</code> of your argument to funnel the memory-like objects into your optimised <code>MemView</code> function</li><li>At the low level, use <code>MemView</code> for the implementation of the optimised version</li></ul><p>An example could be:</p><pre><code class="language-julia hljs"># Dispatch on `MemKind`
my_hash(x) = my_hash(MemKind(typeof(x)), x)

# For objects that are bytes, call the function taking only the memory
# representation of `x`
my_hash(::IsMemory{&lt;:MemView{UInt8}}, x) = my_hash(ImmutableMemView(x))

# IsMemory with eltype other than UInt8 can&#39;t use the fast low-level function
my_hash(T::IsMemory, x) = my_hash(NotMemory(), x)

function my_hash(::NotMemory, x)
    # fallback implementation
end

function my_hash(mem::ImmutableMemView{UInt8})
    # some optimised low-level memory manipulation with `mem` of bytes
end

# Handle e.g. strings separately, since they are not semantically equal to
# an array of elements in memory, but for this method in particular,
# we want to treat strings as if they are.
function my_hash(x::Union{String, SubString{String}})
    my_hash(MemView(x))
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« MemViews</a><a class="docs-footer-nextpage" href="../base/">MemViews in Base »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Saturday 22 June 2024 10:05">Saturday 22 June 2024</span>. Using Julia version 1.12.0-DEV.766.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
